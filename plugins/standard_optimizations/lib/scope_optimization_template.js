"use strict";

/**
 * This template provides structure for certain scope optimizations and
 * helps reduce repeated/duplicated code.
 */

var topologically_sort_scopes = require('../../../ir/topologically_sort_scopes');

/**
 * @param {Object} scope_data The scope_data object generated by ir_gen
 * @param {function} validator Takes a scope as argument, returns boolean
 * @param {function} process Processes a scope, returns undefined
 * @param {string} verb The string to use for console.log message
 * @returns {Object} An optimized version on the input scope_data
 */
function process_scopes (scope_data, validator, process, verb) {

  // Determine which scopes cannot be removed
  var required_scope_ids = {};
  var name, id;
  for (name in scope_data.root_element_scopes) {
    id = scope_data.root_element_scopes[name].get_identity();
    required_scope_ids[id] = true;
  }

  var sorted_scopes = topologically_sort_scopes(scope_data.scopes);
  var kept_scopes = [];
  var flushed = 0;
  var inlined = 0;
  var pre_count, post_count;

  for (var i = 0; i < sorted_scopes.length; i++) {
    var scope = sorted_scopes[i];
    var required = required_scope_ids[scope.get_identity()];
    if (!required && validator(scope)) {
      pre_count = scope.get_instance_count();
      process(scope);
      post_count = scope.get_instance_count();
      if (post_count === 0) {
        scope.flush();
        flushed++;
      } else {
        kept_scopes.push(scope);
      }
      inlined += (pre_count - post_count);
    } else {
      kept_scopes.push(scope);
    }
  }

  if (flushed || inlined) {
    console.log(verb, flushed, flushed === 1 ? 'scope.' : 'scopes.', inlined, 'scope instances inlined.');
  }

  // TODO: Why must the sorted scopes be reversed?
  scope_data.scopes = kept_scopes.reverse();
  return scope_data;
}

module.exports = process_scopes;
